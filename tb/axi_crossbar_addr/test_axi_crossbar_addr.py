import itertools
import logging
import os
import warnings

import cocotb_test.simulator
import pytest

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge
from cocotb.regression import TestFactory

# Suppress deprecation warnings that might be generated by some imports or internal library usage
warnings.filterwarnings("ignore", category=DeprecationWarning, module="importlib.abc")

# Define test cases as a list of tuples.
# Each tuple contains an address, the expected master select output, and the expected region output.
# The address is mapped to specific masters and regions based on the logic in the DUT (Design Under Test).
test_cases = [
    (0x00000000, 0, 0),  # Address 0x00000000 should select master 0, region 0
    (0x01000000, 1, 0),  # Address 0x01000000 should select master 1, region 0
    (0x02000000, 2, 0),  # Address 0x02000000 should select master 2, region 0
    (0x03000000, 3, 0),  # Address 0x03000000 should select master 3, region 0
    (0x00010000, 0, 0),  # Address 0x00010000 should also select master 0, region 0
    (0x01010000, 1, 0),  # Address 0x01010000 should also select master 1, region 0
    (0xFFFFFFFF, 3, 0),  # The highest address value, 0xFFFFFFFF, should select master 3, region 0
]

class TB:
    def __init__(self, dut):
        """ Testbench class for the DUT (Design Under Test) """
        self.dut = dut  # Assign the DUT to a local attribute
        self.log = logging.getLogger("cocotb.tb")  # Set up logging for the testbench
        self.log.setLevel(logging.DEBUG)  # Set the logging level to DEBUG for detailed output

        # Start a clock for the DUT with a 10ns period.
        # This clock runs indefinitely and drives the 'clk' signal of the DUT.
        cocotb.start_soon(Clock(dut.clk, 10, units="ns").start())

    async def cycle_reset(self):
        """ Cycle the reset signal to initialize the DUT """
        self.dut.rst.setimmediatevalue(0)  # Set the reset signal to 0 (inactive)
        await RisingEdge(self.dut.clk)  # Wait for a rising edge of the clock
        await RisingEdge(self.dut.clk)  # Wait for another rising edge of the clock
        self.dut.rst.value = 1  # Activate the reset signal
        await RisingEdge(self.dut.clk)  # Wait for the reset to propagate (1 clock cycle)
        await RisingEdge(self.dut.clk)  # Wait for another clock cycle with reset active
        self.dut.rst.value = 0  # Deactivate the reset signal
        await RisingEdge(self.dut.clk)  # Wait for a rising edge of the clock to ensure reset is deactivated
        await RisingEdge(self.dut.clk)  # Wait for another rising edge of the clock

    async def run_test(self, address, expected_m_select, expected_m_axi_aregion):
        """ Run a single test case with the given address and expected results """
        
        # Set the input address on the 's_axi_aaddr' signal and assert 's_axi_avalid' to indicate valid data
        self.dut.s_axi_aaddr.value = address
        self.dut.s_axi_avalid.value = 1

        # Wait for one clock edge, then clear the valid signal (handshake protocol)
        await RisingEdge(self.dut.clk)
        self.dut.s_axi_avalid.value = 0

        # Wait until the 's_axi_aready' signal is asserted, indicating the DUT has accepted the address
        while not self.dut.s_axi_aready.value:
            await RisingEdge(self.dut.clk)

        # Check if the DUT's output matches the expected master select and region values
        assert self.dut.m_select.value == expected_m_select, f"Address: {hex(address)}, Expected m_select: {expected_m_select}, Got: {self.dut.m_select.value}"
        assert self.dut.m_axi_aregion.value == expected_m_axi_aregion, f"Address: {hex(address)}, Expected m_axi_aregion: {expected_m_axi_aregion}, Got: {self.dut.m_axi_aregion.value}"

        # Log the result of the test case
        self.log.info(f"Test passed for address: {hex(address)}")

@cocotb.test()
async def test_axi_crossbar_addr(dut):
    """ Test the axi_crossbar_addr module """

    tb = TB(dut)  # Instantiate the testbench class with the DUT
    await tb.cycle_reset()  # Perform a reset cycle to initialize the DUT

    # Iterate over all defined test cases and run each one
    for address, expected_m_select, expected_m_axi_aregion in test_cases:
        await tb.run_test(address, expected_m_select, expected_m_axi_aregion)  # Run the test case

    tb.log.info("All test cases passed!")  # Log that all test cases have passed

# cocotb-test integration for pytest

# Define the test and RTL directories for locating test files and source files
tests_dir = os.path.abspath(os.path.dirname(__file__))
rtl_dir = os.path.abspath(os.path.join(tests_dir, '..', '..', 'responses'))

# Define a parameterized pytest function that will pass different sets of parameters to the simulation
@pytest.mark.parametrize("parameters", [
    {
        'S': 0,  # Start index for simulation instances
        'S_COUNT': 4,  # Number of slave interfaces
        'M_COUNT': 4,  # Number of master interfaces
        'ADDR_WIDTH': 32,  # Address bus width
        'ID_WIDTH': 8,  # ID bus width
        'S_THREADS': 2,  # Number of threads per slave interface
        'S_ACCEPT': 16,  # Number of outstanding transactions per slave interface
        'M_REGIONS': 1,  # Number of memory regions
        'M_BASE_ADDR': 0,  # Base address for the memory regions
        'M_ADDR_WIDTH': 24,  # Address width for memory regions
        'M_CONNECT': 15,  # Connectivity matrix (bit mask) for master interfaces
        'M_SECURE': 0,  # Security configuration for master interfaces
        'WC_OUTPUT': 0,  # Configuration for write combining output
    }
])
def test_axi_crossbar_addr_pytest(request, parameters):
    """ Pytest function for running the cocotb simulation """

    dut = "axi_crossbar_addr"  # Specify the top-level module for simulation
    module = os.path.splitext(os.path.basename(__file__))[0]  # Extract the current module name
    toplevel = dut  # Assign the top-level module name

    # Specify the Verilog source files required for the simulation
    verilog_sources = [
        os.path.join(rtl_dir, f"{dut}.v"),
    ]

    # Convert the parameters dictionary to environment variables
    extra_env = {f'PARAM_{k}': str(v) for k, v in parameters.items()}

    # Define the directory for storing the simulation build artifacts
    sim_build = os.path.join(tests_dir, "sim_build", request.node.name.replace('[', '-').replace(']', ''))

    # Run the simulation with the specified settings
    cocotb_test.simulator.run(
        python_search=[tests_dir],  # Python search path for cocotb
        verilog_sources=verilog_sources,  # Verilog source files
        toplevel=toplevel,  # Top-level module for the simulation
        module=module,  # Python module containing the cocotb test
        parameters=parameters,  # Parameters to pass to the simulation
        sim_build=sim_build,  # Directory for storing build artifacts
        extra_env=extra_env,  # Extra environment variables
    )
